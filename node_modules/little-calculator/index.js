const Token = require('./Token').Token
const TOKEN_TYPE = require('./Token').TOKEN_TYPE
const IllegalError = require('./error/IllegalError')
const MAX_PRIORITY = 6


class Calculator {
    constructor(debugMode = false) {
        this.debugMode = debugMode
        this.parencount = 0  // 括号个数
        this.infixExp = [] // 中缀表达式
        this.prepareTokens()  // 预先生成运算符的tokens
        this.makeTokenMap()   // 便于根据运算符名找到tokens数组中位置
    }

    prepareTokens() {
        this.tokens = [
            new Token('#', TOKEN_TYPE.ENDEXPR),
            new Token('(', TOKEN_TYPE.LEFTPAREN),
            new Token(')', TOKEN_TYPE.RIGHTPAREN),
            new Token('~', TOKEN_TYPE.UNARYOP, 6),       // 负号
            new Token('abs', TOKEN_TYPE.UNARYOP, 6),     // 求绝对值
            new Token('sqrt', TOKEN_TYPE.UNARYOP, 6),    // 开平方根
            new Token('exp', TOKEN_TYPE.UNARYOP, 6),     // e的x次
            new Token('ln', TOKEN_TYPE.UNARYOP, 6),      // e为底数的对数
            new Token('log10', TOKEN_TYPE.UNARYOP, 6),   // 10为底数的对数
            new Token('sin', TOKEN_TYPE.UNARYOP, 6),     // 求sin x
            new Token('cos', TOKEN_TYPE.UNARYOP, 6),     // 求cos x
            new Token('tan', TOKEN_TYPE.UNARYOP, 6),     // 求tan x
            new Token('+', TOKEN_TYPE.BINARYOP, 4),      // 二元+
            new Token('-', TOKEN_TYPE.BINARYOP, 4),      // 二元-
            new Token('*', TOKEN_TYPE.BINARYOP, 5),      // 乘法
            new Token('/', TOKEN_TYPE.BINARYOP, 5),      // 除法
            new Token('%', TOKEN_TYPE.BINARYOP, 5),      // 除模取余
            new Token('^', TOKEN_TYPE.BINARYOP, 6),      // 指数运算
        ]
    }

    makeTokenMap() {
        this.tokenIndexMap = {}
        for (let i = 1; i < this.tokens.length; i++) {
            this.tokenIndexMap[this.tokens[i].name] = i
        }
    }

    /**
     * 
     * @param {Number} pos 在tokens数组中索引
     * @param {Number} a 操作数
     */
    doUnary(pos, a) {
        switch (pos) {
            case 3:
                return -a
            case 4:     // 求绝对值
                return Math.abs(a)
            case 5:     // 求平方根
                if (a >= 0) {
                    return Math.sqrt(a)   
                } else {
                    throw new IllegalError('负数不能开平方')
                }
            case 6:
                return Math.exp(a)
            case 7:
                if (a > 0) {
                    return Math.log(a)
                } else {
                    throw new IllegalError('非正数不能求ln')
                }
            case 8:
                if (a > 0) {
                    return Math.log10(a)
                } else {
                    throw new IllegalError('非正数不能求log10')
                }
            case 9:
                return Math.sin(a)
            case 10:
                return Math.cos(a)
            case 11:
                return Math.tan(a)
        }
        throw new IllegalError(`未知运算符，位置${pos}`)
    }


    /**
     * 
     * @param {Number} pos 在tokens数组中索引
     * @param {Number} a 操作数
     * @param {Number} b 操作数
     */
    doBinary(pos, a, b) {
        switch (pos) {
            case 12:
                return (a + b)
            case 13:
                return (a - b)
            case 14:
                return (a * b)
            case 15:
                if (b === 0) {
                    throw new IllegalError('除数不能为0')
                }
                return (a / b)
            case 16:
                if (b === 0) {
                    throw new IllegalError('除数不能为0')
                }
                return (a % b)
            case 17:
                return Math.pow(a, b)
            default:
                throw new IllegalError(`未知运算符，位置${pos}`)
        }
    }

    /**
     * 计算结果
     * @param {string} raw 
     */
    compute(raw) {
        raw = raw.toString().trim()
        if (raw.length <= 0) {
            return
        }
        this.infixExp = [] // 清空中缀表达式
        this.preprocess(raw)
        if (this.debugMode) {
            this.dispInfix()
        }
        const postExp = this.transform()
        if (this.debugMode) {
            this.dispPostfix(postExp)
        }
        return this.computeValue(postExp)
    }


    /**
     * 当前位置的前一个符号是否为开始位置
     * @returns {boolean}
     */
    leading() {
        if (this.infixExp.length <= 0)
            return true
        let lastToken = this.tokens[this.infixExp[this.infixExp.length - 1]]
        return lastToken.type === TOKEN_TYPE.LEFTPAREN || lastToken.type === TOKEN_TYPE.UNARYOP
            || lastToken.type === TOKEN_TYPE.BINARYOP
    }


    /**
     * 预处理字符串
     * @param raw
     * @returns {Array}
     */
    preprocess(raw) {
        let index = 0
        while (index < raw.length) {
            let char = raw.charAt(index)
            if (char === ' ' || char === '\n' || char === '\r') { // 忽略空白符
                index++
            } else if (this.isAlpha(char)) { // 字母开头
                index = this.findWord(raw, index)
            } else if (this.isNumberChar(char) || char === '.') {  // 数字开头
                index = this.findNumber(raw, index)
            } else {
                index = this.findSymbol(raw, index)
            }
            if (index <= -1) {
                throw new IllegalError('预处理出错')
            }
        }
        if (this.parencount !== 0) {
            throw new IllegalError('左右括号不匹配')
        }
        this.infixExp.push(0) // 添加终止符，为了算法设计方便另增的
    }

    /**
     * 提取单词运算符（如sin，cos）
     * @param {String} exp
     * @param {Number} index
     * @return {Number}
     */
    findWord(exp, index) {
        let word = ''
        let char = exp.charAt(index)
        while (this.isAlpha(char) || this.isNumberChar(char)) {
            word += char
            index++
            char = exp.charAt(index)
        }
        if (!(word in this.tokenIndexMap)) {
            throw new IllegalError(`${word}不是合法标识符`)
        }
        const pos = this.tokenIndexMap[word]
        const token = this.tokens[pos]
        if (this.leading()) {
            if (token.type === TOKEN_TYPE.BINARYOP) {
                throw new IllegalError(`${token.name}位置不正确`)
            } else {
                this.infixExp.push(pos)
            }
        } else {
            if (token.type !== TOKEN_TYPE.BINARYOP) {
                throw new IllegalError(`${token.name}应变为二元运算符`)
            } else {
                this.infixExp.push(pos)
            }
        }
        return index
    }

    /**
     * 提取数字
     * @param {String} exp 原始表达式字符串
     * @param {Number} index 
     * @returns {Number} 数字之后索引
     */
    findNumber(exp, index) {
        if (!this.leading()) {
            throw new IllegalError('常量位置不正确！')
        }
        let number = ''
        let char = exp.charAt(index)
        while (this.isNumberChar(char) || char === '.') {
            number += char
            index++
            char = exp.charAt(index)
        }
        this.tokens.push(new Token('number', TOKEN_TYPE.OPRAND, 0, parseFloat(number)))
        this.infixExp.push(this.tokens.length - 1)
        return index
    }

    /**
     * 提取一个符号或括号
     * @param {string} exp
     * @param {Number} index
     * @return {Number}
     */
    findSymbol(exp, index) {
        const char = exp.charAt(index)
        index++
        if (!(char in this.tokenIndexMap)) {
            throw new IllegalError(`${char}无法识别`)
        }
        const pos = this.tokenIndexMap[char]
        const token = this.tokens[pos]

        if (this.leading()) {           // 之前位置是开始位置
            if (token.type === TOKEN_TYPE.RIGHTPAREN) {
                throw new IllegalError(`右括号出现错误`)
            } else if (token.type !== TOKEN_TYPE.BINARYOP) {
                this.infixExp.push(pos)
            } else {
                if (char === '+') {  // “+”号识别为表示正数，什么都不做

                }
                else if (char === '-') { // “-”号识别为表示负数，将“~”放入infix
                    this.infixExp.push(this.tokenIndexMap['~'])
                } else {
                    throw new IllegalError(`${char}位置不正确！`)
                }
            }
        } else {
            if (token.type === TOKEN_TYPE.BINARYOP || token.type === TOKEN_TYPE.RIGHTPAREN) {
                this.infixExp.push(pos)
            } else {
                throw new IllegalError(`${char}位置不正确！`)
            }
        }
        if (token.type === TOKEN_TYPE.LEFTPAREN) {
            this.parencount++
        } else if (token.type === TOKEN_TYPE.RIGHTPAREN) {
            this.parencount--
            if (this.parencount < 0) {
                throw new IllegalError(`太多右括号`)
            }
        }
        return index
    }

    /**
     * 中缀表达式转化为后缀表达式
     * @return {Array}
     */
    transform() {
        const postExp = []
        const opStack = []
        for (let i = 0; i < this.infixExp.length; i++) {
            const pos = this.infixExp[i]
            const token = this.tokens[pos]
            switch (token.type) {
                case TOKEN_TYPE.OPRAND:
                    postExp.push(pos)
                    break;
                case TOKEN_TYPE.LEFTPAREN:  // “(”直接入栈
                    opStack.push(pos)
                    break;
                case TOKEN_TYPE.RIGHTPAREN: // 为“)”，出栈直到遇到运算符“(”
                    let prePos = opStack.pop()
                    while (prePos in this.tokens && opStack.length >= 0 &&
                    this.tokens[prePos].type !== TOKEN_TYPE.LEFTPAREN) {
                        postExp.push(prePos)
                        prePos = opStack.pop()
                    }
                    break;
                case TOKEN_TYPE.UNARYOP:
                case TOKEN_TYPE.BINARYOP:
                    let endright = 0
                    while (endright === 0) {
                        if (opStack.length <= 0)
                            endright = 1
                        else if (this.tokens[opStack[opStack.length - 1]].type === TOKEN_TYPE.LEFTPAREN) {
                            endright = 1
                        } else if (this.tokens[opStack[opStack.length - 1]].priority < token.priority) {
                            endright = 1
                        } else if (this.tokens[opStack[opStack.length - 1]].priority === token.priority &&
                                    token.priority === MAX_PRIORITY) {
                            endright = 1
                        } else {
                            postExp.push(opStack.pop())
                            endright = 0
                        }
                    }
                    opStack.push(pos)
                    break
                case TOKEN_TYPE.ENDEXPR:
                    while (opStack.length >= 1) {
                        postExp.push(opStack.pop())
                    }
                    break
                default:
                    break
            }
        }

        postExp.push(0)  // 添加终止符
        return postExp
    }

    /**
     * 输出中缀表达式
     */
    dispInfix() {
        console.log('中缀表达式为：')
        let output = ''
        for (const pos of this.infixExp) {
            const token = this.tokens[pos]
            if (token.isNumber()) {
                output += ` ${token.val}`
            } else {
                output += ` ${token.name}`
            }
        }
        console.log(output)
    }

    dispPostfix(postExp) {
        console.log('后缀表达式为：')
        let output = ''
        for (const pos of postExp) {
            const token = this.tokens[pos]
            if (token.isNumber()) {
                output += ` ${token.val}`
            } else {
                output += ` ${token.name}`
            }
        }
        console.log(output)
    }

    /**
     * 计算后缀表达式的值
     * @param postExp
     * @returns {Number}
     */
    computeValue(postExp) {
        const dataStack = []
        let res = null
        for (const pos of postExp) {
            const token = this.tokens[pos]
            switch (token.type) {
                case TOKEN_TYPE.OPRAND:
                    dataStack.push(token.val)
                    break
                case TOKEN_TYPE.UNARYOP:
                    const a = dataStack.pop()
                    dataStack.push(this.doUnary(pos, a))
                    break
                case TOKEN_TYPE.BINARYOP:
                    const b1 = dataStack.pop()
                    const a1 = dataStack.pop()
                    dataStack.push(this.doBinary(pos, a1, b1))
                    break
                case TOKEN_TYPE.ENDEXPR:
                    res = dataStack.pop()
                    if (dataStack.length > 0) {
                        throw new IllegalError(`表达式不正确`)
                    }
                    break
            }
        }
        return res
    }

    isUndefined(value) {
        return typeof(value) === "undefined"
    }

    /**
     * 判断字符是数字
     * @param {String} c 字符
     * @return {boolean}
     */
    isNumberChar(c) {
        return c >= '0' && c <= '9'
    }

    /**
     * 是否是字母
     * @param {String} ch
     * @returns {boolean}
     */
    isAlpha(ch) {
        return typeof ch === "string" && ch.length === 1
            && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z");
    }

    isOpChar(char) {
        return char === '+' || char === '-' || char === '*' || char === '/'
    }

    /**
     * 
     * @param {Number} lPri 
     * @param {Number} rPri 
     */
    comparePriority(lPri, rPri) {
        const res = lPri - rPri
        if (res > 0) {
            return 1
        } else if (res < 0) {
            return -1
        } else {
            return 0
        }
    }
}

module.exports = Calculator